<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Problem 565</title>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="MathJax-4.0.0/tex-svg.js"></script>
<style>
body { font-family: Arial, sans-serif; margin: 40px; }
h1 { font-size: 1.6em; }
.difficulty { color: gray; font-size: 0.95em; margin-top: 6px; } .skib {  border-left: 4px solid #000; /* Bold left accent */   background-color: lavender; /* Very light gray */   padding: 1px 20px; /* less top/bottom padding, same left/right */   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* Soft depth */}
.skib {
  border-left: 4px solid #000; /* Bold left accent */
  /* we chillin */ /* Very light gray */
  padding: 1px 20px; /* less top/bottom padding, same left/right */
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* Soft depth */
}	
p { line-height: 1.45; }
ol, ul { margin-left: 1.2em; }
li { margin-bottom: 0.4em; }
</style>
</head>
<body>
<h1>Problem 565 - 2013 Tournament of Towns Junior A, P7 of 7</h1>
<h2 class='difficulty'>Difficulty: 7</h2>
<p>Two teams \(A\) and \(B\) play a school ping pong tournament. The team \(A\) consists of \(m\) students, and the team \(B\) consists of \(n\) students where \(m \ne n\).
There is only one ping pong table to play and the tournament is organized as follows: Two students from different teams start to play while other players form a line waiting for their turn to play. After each game the first player in the line replaces the member of the same team at the table and plays with the remaining player. The replaced player then goes to the end of the line.
Prove that every two players from the opposite teams will eventually play against each other.</p>
<h2>Thinking</h2>
<div class=skib>
<p>After a small bit of playing around, I think the main idea is something like this: suppose currently \(A_1\) and \(B_1\) are playing, then we have \(m + n - 2\) other players waiting in line. After these \(m + n - 2\) players, the \(m + n - 2\) players that come next are \(-1\) (cyclically) of the indices of these players, in the same team order. To illustrate what I am saying, suppose \(A\) has \(4\) players, \(B\) has \(3\), with the sequence \(A_2B_2A_3A_4B_3\). Then this is followed by
\[A_2B_2A_3A_4B_3 \to A_1B_1A_2A_3B_2 \to A_4B_3A_1A_2B_1 \to \dots\]
In any case, the reason why every possible match has to happen is <i>due to</i> \(m \neq n\). If \(m = n\), then the sequence of the player queues would just be periodic with period \(m = n\). Since \(m \neq n\), \(A_1 \to A_m\) and \(B_1 \to B_n\) which generates new things every time (well, not <i>every</i> time). This kind of resembles some sort of relatively primeness and number theoretic ideas.</p>
<p>Let us formalize our idea now. I noticed that maybe we can just look at the first \(A_i\) element in each \(m + n - 2\) period and the currently playing \(B_j\) element before the \(m + n - 2\) period loads in - because this is the one bout we are certain will happen. Actually wait, we can just look at the currently playing \(A_i\) element and \(B_j\) element before the \(m + n - 2\) period loads in. Taking the same example as above, this results in the pairs
\[A_1B_1 \to A_4B_3 \to A_3B_2 \to A_2B_1 \to A_1B_3 \to A_4B_2 \to A_3B_1 \to A_2B_3 \to A_1B_2 \to A_4B_1 \to A_3B_3 \to A_2B_2 \]
This is quite literally perfect, and exactly what we need. But I feel like this worked out neatly because of \(\gcd(3, 4) = 1\). Let me take \((4, 2)\) instead, which leads to:
\[A_1B_1 \to A_4B_2 \to A_3B_1 \to A_2B_2\]
which does indeed fail! Wonderful!</p>
<p>To patch this bug, we must consider the other things in the queue sequence. In general, we want \(\gcd(m, n)\) chains of pairs to form, with each chain of length \(\text{lcm}(m, n)\). So optimally, we want \(\gcd(m, n)\) pairs in the first \(m + n - 2\) sequence (add \(A_1\), \(B_1\) to this) that all result in pairwise distinct chains. In the case of \((4, 2)\), the other chain would be one of 
\[A_1B_2 \to A_4B_1 \to A_3B_2 \to A_2B_1 \;\;\;\; \text{or} \;\;\;\; A_2B_1 \to A_1B_2 \to A_4B_1 \to A_3B_2\]
which are of course, effectively the same chain. Note that the differences of elements in the first chain were 0 and 2, and the differences of elements in the second chain were 1 and 3. When the thing doesn't cycle back, the difference stays the same, and when it does cycle back, the difference changes by something we'll have to see in the \((6, 4)\) example:
\[A_1B_1 \to A_6B_4 \to A_5B_3 \to A_4B_2 \to A_3B_1 \to A_2B_4 \to A_1B_3 \to A_6B_2 \to A_5B_1 \to A_4B_4 \to A_3B_3 \to A_2B_2\]
\[A_1B_2 \to A_6B_1 \to A_5B_4 \to A_4B_3 \to A_3B_2 \to A_2B_1 \to A_1B_4 \to A_6B_3 \to A_5B_2 \to A_4B_1 \to A_3B_4 \to A_2B_3\]
The differences in the first chain are 0, 2, 4 and the differences in the second chain are 1, 3, 5. This sort of thing happens because when cycling back we cycle the difference by only multiples of the \(\gcd(m, n)\). So basically the initial members of the set of queues that we want to find have to have differences that form a complete residue set modulo \(\gcd(m, n)\). </p>
<p>Now that we have an objective in mind, let us first clarify how we know a match happens when given a queue - basically, we look at a person, and go before them until someone of another team is reached. Then we know that this match has been played. This technique doesn't cover all the matches played by a person, but overall counts every match exactly once (at least the ones that don't cross into the next \(m + n - 2\)). Define the difference of a pair (basically of a point) to be the \(i - j\) where \(i\) is the index of \(A\) and \(j\) is the index of \(B\) - regardless of whether the point is in \(A\) or \(B\). We want the set of differences of every point to cover every residue modulo \(\gcd(m, n)\).</p>
<p>Now, note that as we move along the queue, the difference only increases or decreases by \(1\), but we want to go from \(0\) to \(m - n\), which means every residue must obviously be covered (\(\gcd(m, n) \mid m - n\)) and highlights once again the importance of \(m \neq n\).</p>
</div>
<h2>Idea</h2>
<p>Really cool problem - an interesting technique I found here is that when stuck with a subproblem, try to formulate the subproblem as if you were trying to explain it to someone without telling them the entire problem. Try to make the subproblem as neat as possible.</p>
<p><a href="../problem_tracker.html">Back to Problem List</a></p>
</body>
</html>
