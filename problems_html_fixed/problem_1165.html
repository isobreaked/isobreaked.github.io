<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Problem 1165</title>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="MathJax-4.0.0/tex-svg.js"></script>
<style>
body { font-family: Arial, sans-serif; margin: 40px; }
h1 { font-size: 1.6em; }
.difficulty { color: gray; font-size: 0.95em; margin-top: 6px; } .skib {  border-left: 4px solid #000; /* Bold left accent */   background-color: lavender; /* Very light gray */   padding: 1px 20px; /* less top/bottom padding, same left/right */   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* Soft depth */}
.skib {
  border-left: 4px solid #000; /* Bold left accent */
  /* we chillin */ /* Very light gray */
  padding: 1px 20px; /* less top/bottom padding, same left/right */
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* Soft depth */
}
p { line-height: 1.45; }
ol, ul { margin-left: 1.2em; }
li { margin-bottom: 0.4em; }
</style>
</head>
<body>
<h1>Problem 1165 - 2011 IMO, P4 of 6</h1>
<h2 class='difficulty'>Difficulty: 6</h2>
<p>Let \(n > 0\) be an integer. We are given a balance and \(n\) weights of weight \(2^0, 2^1, \cdots, 2^{n-1}\). We are to place each of the \(n\) weights on the balance, one after another, in such a way that the right pan is never heavier than the left pan. At each step we choose one of the weights that has not yet been placed on the balance, and place it on either the left pan or the right pan, until all of the weights have been placed.
Determine the number of ways in which this can be done.</p>
<h2>Thinking</h2>
<div class='skib'>
<p>It's clear that when we place something on the right pan, then there must be something bigger on the left pan. So for example, if in the first move we place \(n - 1\) on the left pan, then <i>any</i> arrangement after that works. </p>
<p>Small cases: \(n = 1\), the following sequences work
\[(0_L1_L),\;\; (1_L0_L),\;\; (1_L0_R)\]
\(n = 2\), the following (15) sequences work
\[(0_L1_L2_L)\]
\[(0_L2_L1_L), \;\; (0_L2_L1_R)\] 
\[(1_L0_L2_L),\;\; (1_L0_R2_L)\]
\[ (1_L2_L0_L), \;\; (1_L2_L0_R)\]
\[(2_L0_L1_L), \;\; (2_L0_L1_R), \;\; (2_L0_R1_L), \;\; (2_L 0_R 1_R)\]
\[(2_L1_L0_L), \;\; (2_L1_R0_L), \;\; (2_L1_L0_R), \;\; (2_L1_R0_R)\]
</p>
<p>Perhaps we can recurse on \(f(n, s)\) where \(n\) represents \(2^{n-1}\), the power of \(2\) available and \(s\) is the number of slots we have. I tried to do this for a bit and it's very sad. </p>
<p>Oh! Maybe the correct way to think about this is that you're <i>given</i> a sequence of \(n\) numbers and you can color a number \(R\) if a number bigger than it has occurred before it. Meanwhile, if there is nothing bigger before it, then it is forced to be colored \(L\). Everything that is not forced has a choice - so every sequence of numbers has \(2^k\) ways to be colored for some \(k\). This actually gives a proper single-variable recurrence (maybe) but I still don't want to do that.</p>
<p>I did \(n = 4\) for fun and sense some amazing strategy by considering \(0\) and removing it to get the case for \(n - 1\). Remove \(0\) from every single sequence of length \(n\) and you're left with a sequence of length \(n-1\) - if \(0\) is not at the start of the sequence you multiply by 2 the number of valid things of the final sequence, and if it is then you multiply by 1. If it's not at the start then every sequence of length \(n-1\) appears \(n-1\) times so we get \(2(n-1)f(n-1)\) and if it is at the start then we every sequence of length \(n-1\) appears exactly once so we get \(f(n-1)\). So
\[f(n) = (2n-1)f(n-1) \implies f(n) = (2n-1)!!\]  </p>
</div>
<h2>Idea</h2>
The problem has a classic smallcase-inductrecurse vibe going for it. Reframing in terms of sequences was a good idea. 
<p><a href="../problem_tracker.html">Back to Problem List</a></p>
</body>
</html>